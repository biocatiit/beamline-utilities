import os
import re
import json
import glob
import argparse
import shutil

import numpy as np
from scipy import integrate as integrate
import scipy.signal
import matplotlib.pyplot as plt


def loadPrimusDatFile(filename):
    ''' Loads a Primus .dat format file '''

    iq_pattern = re.compile('\s*\d*[.]\d*[+eE-]*\d+\s+-?\d*[.]\d*[+eE-]*\d+\s+\d*[.]\d*[+eE-]*\d+\s*')

    i = []
    q = []
    err = []

    with open(filename, 'rU') as f:
        lines = f.readlines()

    if len(lines) == 0:
        return

    comment = ''
    line = lines[0]
    j=0
    while line.split() and line.split()[0].strip()[0] == '#':
        comment = comment+line
        j = j+1
        line = lines[j]

    fileHeader = {'comment':comment}
    parameters = {'filename' : os.path.split(filename)[1],
                  'counters' : fileHeader}

    if comment.find('model_intensity') > -1:
        #FoXS file with a fit! has four data columns
        is_foxs_fit=True
        imodel = []
    else:
        is_foxs_fit = False

    for line in lines:
        iq_match = iq_pattern.match(line)

        if iq_match:
            if not is_foxs_fit:
                found = iq_match.group().split()
                q.append(float(found[0]))
                i.append(float(found[1]))
                err.append(float(found[2]))
            else:
                found = line.split()
                q.append(float(found[0]))
                i.append(float(found[1]))
                imodel.append(float(found[2]))
                err.append(float(found[3]))


    #Check to see if there is any header from RAW, and if so get that.
    header = []
    for j in range(len(lines)):
        if '### HEADER:' in lines[j]:
            header = lines[j+1:]

    hdict = None

    if len(header)>0:
        hdr_str = ''
        for each_line in header:
            hdr_str=hdr_str+each_line
        try:
            hdict = dict(json.loads(hdr_str))
        except Exception:
            # print 'Unable to load header/analysis information. Maybe the file was not generated by RAW or was generated by an old version of RAW?'
            hdict = {}


    i = np.array(i)
    q = np.array(q)
    err = np.array(err)

    if hdict:
        for each in hdict.iterkeys():
            if each != 'filename':
                parameters[each] = hdict[each]

    return q, i, err, parameters

def get_integrated_intensity(source_dir, fprefix, scan_num):
    flist = glob.glob(os.path.join(source_dir, '{}_{:04d}_*.dat'.format(fprefix, scan_num)))
    flist.sort(key=lambda x: int(x.split('_')[-1].split('.')[0]))

    data = [loadPrimusDatFile(fname) for fname in flist]

    int_intensity = np.array([integrate.trapz(d[1], d[0]) for d in data])

    return int_intensity

def align_intensities(int1, int2, choice):
    """Aligns int2 to int1"""
    if choice == 'both':
        A = np.column_stack([int2, np.ones_like(int2)])
        scale, offset = np.linalg.lstsq(A, int1)[0]
    elif choice == 'scale':
        A = np.column_stack([int2, np.zeros_like(int2)])
        scale, offset= np.linalg.lstsq(A, int1)[0]
        offset = 0
    elif choice == 'offset':
        A = np.column_stack([np.zeros_like(int2), np.ones_like(int2)])
        scale, offset= np.linalg.lstsq(A, int1-int2)[0]
        scale = 1
    elif choice == 'none':
        scale = 1
        offset = 0

    int2 = int2*scale + offset

    # plt.plot(int1)
    # plt.plot(int2)
    # plt.show()

    correlation = scipy.signal.correlate(int1, int2)

    offset = np.argmax(correlation) - (len(int2)-1)

    return offset

def align_by_intensity(source_dir1, fprefix1, scan_num1, source_dir2, fprefix2,
    scan_num2, choice, output_dir):
    int1 = get_integrated_intensity(source_dir1, fprefix1, scan_num1)
    int2 = get_integrated_intensity(source_dir2, fprefix2, scan_num2)

    offset = align_intensities(int1, int2, choice)

    print 'Offset from {} scan {} to {} scan {}: {}'.format(fprefix1, scan_num1, fprefix2, scan_num2, offset)

    flist = glob.glob(os.path.join(source_dir2, '{}_{:04d}_*.dat'.format(fprefix2, scan_num2)))
    flist.sort(key=lambda x: int(x.split('_')[-1].split('.')[0]))

    for f in flist:
        basename = os.path.splitext(os.path.basename(f))[0]
        fnum = int(basename.split('_')[-1])
        new_fnum = fnum+offset

        new_name = '_'.join(basename.split('_')[:-1])
        new_name = '{}_{:04d}.dat'.format(new_name, new_fnum)

        shutil.copyfile(f, os.path.join(output_dir, new_name))

    return offset


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Align scans by their integrated intensity')
    parser.add_argument('source_dir', help='The directory with the files')
    parser.add_argument('file_prefix', help='The file prefix to process')
    parser.add_argument('scan_num1', help='The reference scan number')
    parser.add_argument('scan_num2', help='The scan to align')
    parser.add_argument('-s2', '--source-dir2', metavar='DIR', dest='source_dir2', help='The source directory for the second scan (default: source_dir)')
    parser.add_argument('-fp2', '--file-prefix2', metavar='PREFIX', dest='file_prefix2', help='The file prefix for the second scan (default: file_prefix)')
    parser.add_argument('-o', '--output-dir', metavar='DIR', dest='output_dir', help='The output directory for renamed files (default: source_dir)')
    parser.add_argument('-p', '--preprocess', metavar='PROC', dest='choice', help='Preprocessing for scan_num2. Options are: both, scale, offset, none (default: both)')

    args = parser.parse_args()

    source_dir1 = args.source_dir
    fprefix1 = args.file_prefix
    scan_num1 = int(args.scan_num1)
    scan_num2 = int(args.scan_num2)

    if args.output_dir is not None:
        output_dir = args.output_dir
    else:
        output_dir = source_dir1

    if args.source_dir2 is not None:
        source_dir2 = args.source_dir2
    else:
        source_dir2 = source_dir1

    if args.file_prefix2 is not None:
        fprefix2 = args.file_prefix2
    else:
        fprefix2 = fprefix1

    if args.choice is not None:
        choice = args.choice
    else:
        choice = 'both'

    align_by_intensity(source_dir1, fprefix1, scan_num1, source_dir2, fprefix2,
        scan_num2, choice, output_dir)
